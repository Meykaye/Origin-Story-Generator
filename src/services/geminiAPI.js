// You need to get a free API key from: https://makersuite.google.com/app/apikey
const GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY || 'YOUR_GEMINI_API_KEY_HERE';

export const ClaudeAPI = {
  async complete(prompt, retryCount = 0, maxRetries = 3) {
    console.log('üöÄ Starting Gemini API call...');
    console.log('üìù API Key exists:', !!GEMINI_API_KEY && GEMINI_API_KEY !== 'YOUR_GEMINI_API_KEY_HERE');
    console.log('üìÑ Prompt length:', prompt.length);
    console.log('üîÑ Retry attempt:', retryCount + 1, 'of', maxRetries + 1);
    
    try {
      // Using Gemini 1.5 Flash model (free tier available) with correct API version
      const response = await fetch(`https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        })
      });
      
      console.log('üì° Response status:', response.status);
      console.log('üì° Response ok:', response.ok);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error('‚ùå API Error Response:', errorData);
        
        // Check if it's a retryable error (503, 429, 500, 502, 504)
        const isRetryableError = [500, 502, 503, 504, 429].includes(response.status);
        
        if (isRetryableError && retryCount < maxRetries) {
          const delay = Math.min(1000 * Math.pow(2, retryCount), 10000); // Exponential backoff, max 10s
          console.log(`üîÑ Retrying in ${delay}ms due to ${response.status} error...`);
          
          await new Promise(resolve => setTimeout(resolve, delay));
          return this.complete(prompt, retryCount + 1, maxRetries);
        }
        
        // If not retryable or max retries reached
        if (response.status === 503) {
          throw new Error('Gemini API is temporarily overloaded. Please try again in a few minutes.');
        } else if (response.status === 429) {
          throw new Error('Rate limit exceeded. Please wait a moment and try again.');
        } else {
          throw new Error(`Gemini API request failed: ${response.status} ${response.statusText}. ${errorData.error?.message || ''}`);
        }
      }
      
      const data = await response.json();
      console.log('‚úÖ API Response received:', data);
      
      // Check if we have candidates
      if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
        console.error('‚ùå No content in response:', data);
        throw new Error('No content generated by Gemini API');
      }
      
      let responseText = data.candidates[0].content.parts[0].text;
      console.log('üìù Raw response text:', responseText.substring(0, 200) + '...');
      
      // Clean up markdown formatting and fix JSON issues
      responseText = responseText.replace(/```json\s?/g, "").replace(/```\s?/g, "").trim();
      
      // Try to fix common JSON issues
      try {
        // First attempt to parse as-is
        JSON.parse(responseText);
        console.log('üßπ JSON is valid, returning as-is');
        return responseText;
      } catch (jsonError) {
        console.log('üîß JSON parse failed, attempting to fix...');
        
        // Try to fix common JSON escape issues
        let fixedText = responseText;
        
        // Fix unescaped quotes in text content
        fixedText = fixedText.replace(/"([^"]*)":\s*"([^"]*)"/g, (match, key, value) => {
          // Escape quotes and backslashes in the value
          const escapedValue = value
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
          return `"${key}": "${escapedValue}"`;
        });
        
        // Try parsing the fixed version
        try {
          JSON.parse(fixedText);
          console.log('‚úÖ Fixed JSON successfully');
          return fixedText;
        } catch (stillBroken) {
          console.log('üîß Advanced JSON fixing...');
          
          // More aggressive fix - extract JSON structure and rebuild
          const jsonMatch = fixedText.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            let jsonStr = jsonMatch[0];
            
            // Replace problematic characters more aggressively
            jsonStr = jsonStr
              // eslint-disable-next-line no-control-regex
              .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') // Remove control characters
              .replace(/\\(?!["\\/bfnrt])/g, '\\\\') // Fix invalid escape sequences
              .replace(/\n/g, '\\n')
              .replace(/\r/g, '\\r')
              .replace(/\t/g, '\\t');
            
            try {
              JSON.parse(jsonStr);
              console.log('‚úÖ Aggressively fixed JSON');
              return jsonStr;
            } catch (finalError) {
              console.error('‚ùå Could not fix JSON:', finalError);
              throw new Error('Invalid JSON response from API. Please try again.');
            }
          } else {
            throw new Error('No valid JSON structure found in response');
          }
        }
      }
    } catch (error) {
      console.error("‚ùå Gemini API Error:", error);
      
      // Check if it's a network error that we should retry
      const isNetworkError = error.name === 'TypeError' && error.message.includes('fetch');
      const isTimeoutError = error.message.includes('timeout') || error.message.includes('ECONNRESET');
      
      if ((isNetworkError || isTimeoutError) && retryCount < maxRetries) {
        const delay = Math.min(1000 * Math.pow(2, retryCount), 10000);
        console.log(`üîÑ Retrying in ${delay}ms due to network error...`);
        
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.complete(prompt, retryCount + 1, maxRetries);
      }
      
      // Provide helpful error messages
      if (error.message.includes('API_KEY_INVALID') || error.message.includes('403')) {
        throw new Error('Invalid API key. Please check your Gemini API key.');
      } else if (error.message.includes('QUOTA_EXCEEDED')) {
        throw new Error('API quota exceeded. Please try again later.');
      } else if (error.message.includes('overloaded') || error.message.includes('503')) {
        throw new Error('Gemini API is temporarily overloaded. Please try again in a few minutes.');
      } else if (isNetworkError) {
        throw new Error('Network connection failed. Please check your internet connection and try again.');
      } else {
        throw new Error(`Failed to generate content: ${error.message}`);
      }
    }
  }
};